/**
 * Open Banking Gateway - Consent Authorization API.
 * Interface used by the PsuUserAgent to present consent authorization services to the PSU. The consent authorization process is triggered by redirecting the PSU from the [TppBankingApi](https://adorsys.github.io/open-banking-gateway/doc/latest/architecture/dictionary#TppBankingApi) (2<sub>a</sub>) over the [FinTechApi](https://adorsys.github.io/open-banking-gateway/doc/latest/architecture/dictionary#FinTechApi) (2<sub>b</sub>) to the /consent/{auth-id} entry point of this [ConsentAuthorisationApi](https://adorsys.github.io/open-banking-gateway/doc/latest/architecture/dictionary#ConsentAuthorisationApi) (2<sub>c</sub>). The decision on whether the authorization process is embedded or redirected is taken by this ConsentAuthorisationApi.  The following picture displays the overall architecture of this open banking consent authorisation api:   ![High level architecture](/img/open-banking-consent-authorisation-api.png)   #### User Agent This Api assumes that the PsuUserAgent is a modern browsers that : * automatically detects the \"302 Found\" response code and proceeds with the associated location url, * stores httpOnly cookies sent with the redirect under the given domain and path as defined by [RFC 6265](https://tools.ietf.org/html/rfc6265).  This Api also assumes any other PsuUserAgent like a native mobile or a desktop application can simulate this same behavior of amodern browser with respect to 30X and Cookies.    #### Redirecting to the ConsentAuthorisationApi (2<sub>a</sub>) Any service request of the FinTechUI to the FinTechApi (1<sub>a</sub>) will be forwarded to the TppBankingApi (1<sub>b</sub>). This forward might contain a [PsuConsentSession](https://adorsys.github.io/open-banking-gateway/doc/latest/architecture/dictionary#PsuConsentSession) that is used to identify the PSU in the world of the TPP.  The TppBankingApi uses the provided PsuConsentSession to retrieve an eventualy suitable consent that will be used to forward the corresponding service request to the OpenBankingApi (1<sub>c</sub>) of the ASPSP. If there is no suitable consent, the TPP might still send a consent initiation request to the OpenBankingApi (1<sub>c</sub>). Whether this request is sent or not depends on the design of the target OpenBankingApi. Finally, the TppBankingApi will if necessary instruct the FinTechApi (2<sub>a</sub>) to redirect the PsuUgerAgent (2<sub>b</sub>) to the /consent/{auth-id} entry point of  the ConsentAuthorisationApi (2<sub>c</sub>).      #### Issolation Authorisation Request Processing The auth-id parameter is used to make sure paralell authorization requests are not mixup.      #### SessionCookies and XSRF Each authorisation session started will be associated with a proper SessionCookie and a corresponding XSRF-TOKEN. * The request that sets a session cookie (E<sub>1</sub>) also add the X-XSRF-TOKEN to the response header. * The cookie path is always extended with the corresponding auth-id, so two Authorization processes can not share state.  * Each authenticated request sent to the ConsentAuthorisationApi will provide the X-XSRF-TOKEN matching the sent SessionCookie.  #### RedirectCookie and XSRF (R<sub>1</sub>) In a redirect approach (Redirecting PSU to the ASPSP), the The retruned AuthorizeResponse object contains information needed to present a suitable redirect info page to the PSU. Redirection can either be actively performed by the UIApplication or performed as a result of a 30x redirect response to the PsuUserAgent. In both cases, a RedirectCookie will be associated with the  PsuUserAgent and a corresponding XSRF-TOKEN named redirectState will be addedto the back redirect url.      #### Final Result of the Authorization Process The final result of the authorization process is a PsuCosentSession that is returned by the token endpoint of the TppBankingAPi to the FinTechApi (4<sub>c</sub>). This handle will (PsuCosentSession) will be stored by the FinTechApi and added a PSU identifying information to each service request associated with this PSU.  
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { AuthorizeRequest } from '../model/authorizeRequest';
import { DenyRequest } from '../model/denyRequest';
import { InlineResponse200 } from '../model/inlineResponse200';
import { PsuAuthRequest } from '../model/psuAuthRequest';
import { PsuMessage } from '../model/psuMessage';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class UpdateConsentAuthorizationService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Consent authorization is denied - consent is blocked. Closes this session and redirects the PSU back to the FinTechApi or close the application window. 
     * Closes this session and redirects the PSU back to the FinTechApi or close the application window. In any case, the session of the user will be closed and cookies will be deleted with the response to this request. 
     * @param authId Used to distinguish between different consent authorization processes started by the same PSU. Also included in the corresponding cookie path to limit visibility of the consent cookie to the corresponding consent process. 
     * @param xRequestID Unique ID that identifies this request through common workflow. Shall be contained in HTTP Response as well. 
     * @param X_XSRF_TOKEN XSRF parameter used to validate a SessionCookie. The token matches the auth-id included in the requestpath and prefixing the cookie. 
     * @param denyRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public denyUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, denyRequest: DenyRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public denyUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, denyRequest: DenyRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public denyUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, denyRequest: DenyRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public denyUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, denyRequest: DenyRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authId === null || authId === undefined) {
            throw new Error('Required parameter authId was null or undefined when calling denyUsingPOST.');
        }
        if (xRequestID === null || xRequestID === undefined) {
            throw new Error('Required parameter xRequestID was null or undefined when calling denyUsingPOST.');
        }
        if (X_XSRF_TOKEN === null || X_XSRF_TOKEN === undefined) {
            throw new Error('Required parameter X_XSRF_TOKEN was null or undefined when calling denyUsingPOST.');
        }
        if (denyRequest === null || denyRequest === undefined) {
            throw new Error('Required parameter denyRequest was null or undefined when calling denyUsingPOST.');
        }

        let headers = this.defaultHeaders;
        if (xRequestID !== undefined && xRequestID !== null) {
            headers = headers.set('X-Request-ID', String(xRequestID));
        }
        if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
            headers = headers.set('X-XSRF-TOKEN', String(X_XSRF_TOKEN));
        }

        // authentication (sessionCookie) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/v1/consent/${encodeURIComponent(String(authId))}/deny`,
            denyRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generic challenge response end point for updating consent session with PSU authentication data while requesting remaining challenges for the ongoing authorization process. 
     * Update consent session with PSU auth data whereby requesting remaining challenges for the ongoing authorization process. Returns 202 if one should proceed to some other link. Link to follow is in \&#39;Location\&#39; header. 
     * @param authId Used to distinguish between different consent authorization processes started by the same PSU. Also included in the corresponding cookie path to limit visibility of the consent cookie to the corresponding consent process. 
     * @param xRequestID Unique ID that identifies this request through common workflow. Shall be contained in HTTP Response as well. 
     * @param X_XSRF_TOKEN XSRF parameter used to validate a SessionCookie. The token matches the auth-id included in the requestpath and prefixing the cookie. 
     * @param redirectCode Code used to retrieve a redirect session. This is generaly transported as a query parameter
     * @param psuAuthRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public embeddedUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, redirectCode?: string, psuAuthRequest?: PsuAuthRequest, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public embeddedUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, redirectCode?: string, psuAuthRequest?: PsuAuthRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public embeddedUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, redirectCode?: string, psuAuthRequest?: PsuAuthRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public embeddedUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, redirectCode?: string, psuAuthRequest?: PsuAuthRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authId === null || authId === undefined) {
            throw new Error('Required parameter authId was null or undefined when calling embeddedUsingPOST.');
        }
        if (xRequestID === null || xRequestID === undefined) {
            throw new Error('Required parameter xRequestID was null or undefined when calling embeddedUsingPOST.');
        }
        if (X_XSRF_TOKEN === null || X_XSRF_TOKEN === undefined) {
            throw new Error('Required parameter X_XSRF_TOKEN was null or undefined when calling embeddedUsingPOST.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (redirectCode !== undefined && redirectCode !== null) {
            queryParameters = queryParameters.set('redirectCode', <any>redirectCode);
        }

        let headers = this.defaultHeaders;
        if (xRequestID !== undefined && xRequestID !== null) {
            headers = headers.set('X-Request-ID', String(xRequestID));
        }
        if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
            headers = headers.set('X-XSRF-TOKEN', String(X_XSRF_TOKEN));
        }

        // authentication (sessionCookie) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<InlineResponse200>(`${this.configuration.basePath}/v1/consent/${encodeURIComponent(String(authId))}/embedded`,
            psuAuthRequest,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Provides the ConsentAuthorisationApi with the opportunity to redirect the PSU to the ASPSP. 
     * Provides the ConsentAuthorisationApi with the opportunity to redirect the PSU to the ASPSP. 
     * @param authId Used to distinguish between different consent authorization processes started by the same PSU. Also included in the corresponding cookie path to limit visibility of the consent cookie to the corresponding consent process. 
     * @param xRequestID Unique ID that identifies this request through common workflow. Shall be contained in HTTP Response as well. 
     * @param X_XSRF_TOKEN XSRF parameter used to validate a SessionCookie. The token matches the auth-id included in the requestpath and prefixing the cookie. 
     * @param authorizeRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toAspspGrantUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, authorizeRequest: AuthorizeRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public toAspspGrantUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, authorizeRequest: AuthorizeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public toAspspGrantUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, authorizeRequest: AuthorizeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public toAspspGrantUsingPOST(authId: string, xRequestID: string, X_XSRF_TOKEN: string, authorizeRequest: AuthorizeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authId === null || authId === undefined) {
            throw new Error('Required parameter authId was null or undefined when calling toAspspGrantUsingPOST.');
        }
        if (xRequestID === null || xRequestID === undefined) {
            throw new Error('Required parameter xRequestID was null or undefined when calling toAspspGrantUsingPOST.');
        }
        if (X_XSRF_TOKEN === null || X_XSRF_TOKEN === undefined) {
            throw new Error('Required parameter X_XSRF_TOKEN was null or undefined when calling toAspspGrantUsingPOST.');
        }
        if (authorizeRequest === null || authorizeRequest === undefined) {
            throw new Error('Required parameter authorizeRequest was null or undefined when calling toAspspGrantUsingPOST.');
        }

        let headers = this.defaultHeaders;
        if (xRequestID !== undefined && xRequestID !== null) {
            headers = headers.set('X-Request-ID', String(xRequestID));
        }
        if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
            headers = headers.set('X-XSRF-TOKEN', String(X_XSRF_TOKEN));
        }

        // authentication (sessionCookie) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/v1/consent/${encodeURIComponent(String(authId))}/toAspsp/grant`,
            authorizeRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
